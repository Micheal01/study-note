# 1.重排序

重排序有编译器重排序，和处理器重排序（指令并行重排序，内存系统重排序）

目的是为了提高指令的并行度，替身性能。

# 2.数据依赖性

如果单个线程中两个操作具有数据依赖性，比如：

```java
int a = 1 ;
int b = a ;
```



这样的两个操作就具有数据依赖性质

**重排序不会改变具有数据依赖性的两个操作的执行顺序**

# 3. as-if-serial

as-if-serial 指的是不管怎么重排序，**单线程**的执行结果不能被改变。在存在数据依赖性的操作不重排序的前提之下。其他的操作是可以重排序的

# 4. 内存屏障

内存屏障有四种，但是不是所有处理器都存在这四种内存屏障：

* LoadLoad： 这个屏障后面的读操作都不会和它前面的读操作进行重排序(不是所有处理器都支持)，也就是说，

  ```java
  int a = 1 ;
  int b = a ;
  LoadLoad 屏障
  int c = a ;
  int d = a ;
  ```

  c和d赋值的操作不能和b重排序(这里的b,c,d没有书记依赖性)

  

* LoadStore :  这个屏障后面的写操作都不会和它前面的读操作进行重排序(不是所有处理器都支持)，也就是说，

  ```java
  int a = 1 ;
  int b = a ;
  LoadStroe 屏障
  int c = 2 ;
  int d = 3 ;
  ```

  c和d赋值的操作不能和b重排序(这里的b,c,d没有书记依赖性)

  

* StoreStore : 这个屏障后面的写操作都不会和它前面的写操作进行重排序(不是所有处理器都支持) 

* StoreLoad : (现代多处理器都支持) 它是一个“全能型屏障”同属具有前面三个的效果，但是**执行这个屏障的开销比较昂贵，因为他可以吧当前处理器缓冲区的数据全部刷新到主内存中**。

# 5. happens-before

它指的是如果一个操作  A-happens-before -B, 那么A 操作一定对B操作可见（内存的可见性）

也就是说如果操作A-happens-before -B ,那么 B 一定能知道 A 对内存数据的修改。

# 6. 锁的内存语义

* **锁的释放的内存语义**：他会把当前本地换存中的共享变量的值都刷新到主内存中
* **锁的获取的内存语义**：他会把当前**临界区**本地内存置为无效，线程将重新从主内存中读取共享变量

**临界区**：获取锁和释放锁之间的操作区域。

# 7. volatile

**volatile能够保证变量的可见性以及变量普通读/写操作的原子性（这点其实是jvm指令保证的）。但是不能保证 变量复合操作的原子性。**

## 7.1 volatile 读的内存语义+内存屏障

* **内存屏障**：volatile读的后面会插入LoadLoad+LoadStroe内存屏障，也就是说一个volatile变量读的后面任何变量的读写操作都不会重排序到这个 volatile变量读之前
* **内存语义**：volatile 变量的读 具有与锁的获取具有相同的内存效果，他会把当前**临界区**本地内存置为无效，线程将重新从主内存中读取共享变量

**总结**：这样可以实现 volatile 变量读后面的读都能获取主内存的值

## 7.2 volatile 写的内存语义+内存屏障

- **内存屏障**：volatile写的后面会插入StroeLoad内存屏障，也就是说一个volatile变量写的后面任何变量的读操作都不会重排序到这个 volatile变量写之前；volatile写的前面会插入StroeStroe内存屏障,也就是说一个volatile变量写的前面任何变量的写操作都不会重排序到这个 volatile变量写之后；
- **内存语义**：volatile 变量的写 具有与锁的释放具有相同的内存效果，他会把当前本地换存中的共享变量的值都刷新到主内存中

**总结**：这样就能将 volatile变量读前面的所有写操作的值都刷新到主内存，使得一系列的写操作对其他线程可见。

# 8. CAS

## 8.1 CAS java 中的函数介绍

CAS(compare and swap)，比较之后交换。这事一个现在处理器都提供的一个命令，在java中由sun.misc.Unsafe 这个工具类，提供一系列的实现（这个类在外部不能直接调用）：

* `final native boolean compareAndSwapObject(Object paramObject, long valueOffset, Object expect, Object update)`
* `final native boolean compareAndSwapObject(Object paramObject, long valueOffset, Object expect, Object update)`
* `final native boolean compareAndSwapObject(Object paramObject, long valueOffset, Object expect, Object update)`

参数都是一样的。这里我们解释一下参数的意义：

* `paramObject`: 需要操作的对象，一般都是当前对象（因为我们使用的都是jdk提供的封装类）。
* `valueOffset`：操作对象中封装的属性的内存偏移量，c++本地函数通过这个偏移量获取当前对象内存地址中具体的这个属性的内存地址
* `expect`：旧的预期的值，如果是这个值，才能修改成功
* `update`：即将更新到的值

## 8.2 CAS 内部原理

* 使用 上面 CAS 方法的程序，如果在多处理器（多cpu）环境运行，就会为其加上 lock 前缀，带有这个前缀的该cas指定在现代的处理器中会使用缓存锁定来保证这个变量的指定执行的原子性。
* 该指令的前后的读/写指令会被禁止。
* 执行之后会将该写缓冲区的所有数据刷新刀主内存。

**总结**：可以说该指令 同时实现了volatile 读和写的内存语义。

# 9. 锁的释放和获取的内存语义的实现方式

*  使用 volatile 变量的读——写所具有的内存语义
* 利用CAS附带的volatile 读——写语义。

# 10. juc 的实现基础

juc(java.util.concurrent)包。

![1539076608379](https://github.com/Alan-Jun/study-note/blob/master/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.assets/1539076608379.png)







