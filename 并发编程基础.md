# 1.重排序

重排序有编译器重排序，和处理器重排序（指令并行重排序，内存系统重排序）

目的是为了提高指令的并行度，替身性能。

# 2.数据依赖性

如果单个线程中两个操作具有数据依赖性，比如：

```java
int a = 1 ;
int b = a ;
```



这样的两个操作就具有数据依赖性质

**重排序不会改变具有数据依赖性的两个操作的执行顺序**

# 3. as-if-serial

as-if-serial 指的是不管怎么重排序，**单线程**的执行结果不能被改变。在存在数据依赖性的操作不重排序的前提之下。其他的操作是可以重排序的

# 4. 内存屏障

内存屏障有四种，但是不是所有处理器都存在这四种内存屏障：

* LoadLoad： 这个屏障后面的读操作都不会和它前面的读操作进行重排序(不是所有处理器都支持)，也就是说，

  ```java
  int a = 1 ;
  int b = a ;
  LoadLoad 屏障
  int c = a ;
  int d = a ;
  ```

  c和d赋值的操作不能和b重排序(这里的b,c,d没有书记依赖性)

  

* LoadStore :  这个屏障后面的写操作都不会和它前面的读操作进行重排序(不是所有处理器都支持)，也就是说，

  ```java
  int a = 1 ;
  int b = a ;
  LoadStroe 屏障
  int c = 2 ;
  int d = 3 ;
  ```

  c和d赋值的操作不能和b重排序(这里的b,c,d没有书记依赖性)

  

* StoreStore : 这个屏障后面的写操作都不会和它前面的写操作进行重排序(不是所有处理器都支持) 

* StoreLoad : (现代多处理器都支持) 它是一个“全能型屏障”同属具有前面三个的效果，但是**执行这个屏障的开销比较昂贵，因为他可以吧当前处理器缓冲区的数据全部刷新到主内存中**。

# 5. happens-before

它指的是如果一个操作  A-happens-before -B, 那么A 操作一定对B操作可见（内存的可见性）

也就是说如果操作A-happens-before -B ,那么 B 一定能知道 A 对内存数据的修改。

# 6. 锁的内存语义

* **锁的释放的内存语义**：他会把当前本地换存中的共享变量的值都刷新到主内存中
* **锁的获取的内存语义**：他会把当前**临界区**本地内存置为无效，线程将重新从主内存中读取共享变量

**临界区**：获取锁和释放锁之间的操作区域。

# 7. volatile

**volatile能够保证变量的可见性以及变量普通读/写操作的原子性（这点其实是jvm指令保证的）。但是不能保证 变量复合操作的原子性。**

## 7.1 volatile 读的内存语义+内存屏障

* **内存屏障**：volatile读的后面会插入LoadLoad+LoadStroe内存屏障，也就是说一个volatile变量读的后面任何变量的读写操作都不会重排序到这个 volatile变量读之前
* **内存语义**：volatile 变量的读 具有与锁的获取具有相同的内存效果，他会把当前**临界区**本地内存置为无效，线程将重新从主内存中读取共享变量

**总结**：这样可以实现 volatile 变量读后面的读都能获取主内存的值

## 7.2 volatile 写的内存语义+内存屏障

- **内存屏障**：volatile写的后面会插入StroeLoad内存屏障，也就是说一个volatile变量写的后面任何变量的读操作都不会重排序到这个 volatile变量写之前；volatile写的前面会插入StroeStroe内存屏障,也就是说一个volatile变量写的前面任何变量的写操作都不会重排序到这个 volatile变量写之后；
- **内存语义**：volatile 变量的写 具有与锁的释放具有相同的内存效果，他会把当前本地换存中的共享变量的值都刷新到主内存中

**总结**：这样就能将 volatile变量读前面的所有写操作的值都刷新到主内存，使得一系列的写操作对其他线程可见。

# 8. CAS

## 8.1 CAS java 中的函数介绍

CAS(compare and swap)，比较之后交换。这事一个现在处理器都提供的一个命令，在java中由sun.misc.Unsafe 这个工具类，提供一系列的实现（这个类在外部不能直接调用）：

* `final native boolean compareAndSwapObject(Object paramObject, long valueOffset, Object expect, Object update)`
* `final native boolean compareAndSwapObject(Object paramObject, long valueOffset, Object expect, Object update)`
* `final native boolean compareAndSwapObject(Object paramObject, long valueOffset, Object expect, Object update)`

参数都是一样的。这里我们解释一下参数的意义：

* `paramObject`: 需要操作的对象，一般都是当前对象（因为我们使用的都是jdk提供的封装类）。
* `valueOffset`：操作对象中封装的属性的内存偏移量，c++本地函数通过这个偏移量获取当前对象内存地址中具体的这个属性的内存地址
* `expect`：旧的预期的值，如果是这个值，才能修改成功
* `update`：即将更新到的值

## 8.2 CAS 内部原理

* 使用 上面 CAS 方法的程序，如果在多处理器（多cpu）环境运行，就会为其加上 lock 前缀，带有这个前缀的该cas指定在现代的处理器中会使用缓存锁定来保证这个变量的指定执行的原子性。
* 该指令的前后的读/写指令会被禁止。
* 执行之后会将该写缓冲区的所有数据刷新刀主内存。

**总结**：可以说该指令 同时实现了volatile 读和写的内存语义。

# 9. 锁的释放和获取的内存语义的实现方式

*  使用 volatile 变量的读——写所具有的内存语义
* 利用CAS附带的volatile 读——写语义。

# 10. juc 的实现基础

juc(java.util.concurrent)包。

![1539076608379](https://github.com/Alan-Jun/study-note/blob/master/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.assets/1539076608379.png)

# 11. 双重检查锁

## 11.1 双重检查锁

初期的代码：

```java
public class DoubleCheckedLock{
  private static Instance instance;
  
  public static Instance getInstance(){
    if(instance == null){// 第一次检查
      synchronized(DoubleCheckedLock.class){
        if(instance == null){// 第二次检查
        	instance = new Instance();// 标记为 i
        }  
      }
    }
    return instance;
  }
  
}
```

### 为什么要使用双重检查锁呢？

为了实现绝对的单例，我们需要考略到多线程中的同步问题，这时候使用 synchronized 性能开销相对较大，所以使用的上面的代码，如果第一次检查 instance不为null，那就不需要执行下面的加锁操作。因此可以降低  synchronized 带来的性能开销。

### 这个代码是否存在什么问题呢？

问题出在 标记 i 这个位置，这行代码可以分解为：

```java
memory  = allocate(); // 1. 分配对象的内存空间
ctorinstance(memory);// 2. 初始化对象
instance = memory;// 3. 将instance指向刚分配的内存地址
```

上面这部分代码中2个3之间，可能会重排序（在一些JIT编译器上这种重排序是真实发生的）

如果两个并行的线程A，B掉用这样的代码，如果A走到标记i位置发生了重排序，就有可能发生B线程判断instance!=null,然后他访问对象，但是这个对象还没有初始化或没初始化完成这样的情况。

### 解决的方法

* 不允许2和3重排序
* 允许2个3重排序，但是不允许其他线程“看到”这个重排序（利用初始化过程是同步的这一点）

通过两个方法分别设计两种解决方案：

* 基于volatile的解决方案：

  ```java
  public class DoubleCheckedLock{
    private volatile static Instance instance;
    
    public static Instance getInstance(){
      if(instance == null){
        synchronized(DoubleCheckedLock.class){
          if(instance == null){
          	instance = new Instance();// instance 为volatile 就没问题了
          }  
        }
      }
      return instance;
    }
    
  }
  ```

*  基于类初始化的解决方案

  类的初始化：在Class被加载之后，线程调用之前。初始化的时候会去获取锁，这个锁可以同步多个线程对同一个类的初始化，

  什么时候会初始化？

  * new 一个类的时候
  * 一个类中声明的static方法被调用
  * 一个类中声明的非final的static属性被使用

  了解了这些就可以设计代码了

  ```java
  public class InstanceFactory{
    private static class InstanceHolder{
      public static Instance instance = new Instance();
    }
    public static Instance getInstance(){
      return InstanceHolder.instance;
    }
  }
  ```

  这个代码我们在并发的时候，由于初始化锁的原因，调用getInstance()方法的时候会被同步，这样在第一次初始化的时候，这个instance变量只会被实例化一次。

  # 12.线程

  现代操作系统运行一个程序时，会为它创建一个进程，而线程是轻量级进程，是比进程更小的一个单元。在一个进程中可以创建多个线程。这些线程拥有自己的计数器，堆栈，局部变量等。他们能访问贡献的内存变量。一个线程在一个时刻只能运行在一个处理器和信心上，处理器单核心会在一些线程上做切换，多核处理器线程会同时发生并行以及切换。

  ## 12.1 使用多线程的意义

  * 利用更多的处理器核心：现代处理器都是多核 cpu , 这样的处理器更加擅长并行计算，处理器在提高单核主频（每秒计算速度）的同时也在向着更多的核心发展，怎么更好利用处理器的多个核心呢？大然是使用多线程，同时利用多个核心。
  * 更快的响应时间：有的业务处理是可以拆分成好几步同时运行的。这时候使用多线程去分别处理，肯定相比你一个个串行化处理快

  ## 12.2 线程优先级

  现代操作系统会分出一个个时间片，线程会分配到一个个时间片，当线程时间片用完（线程执行完成也会切换别的线程）就会发生线程调用，并等待下一次分配。线程优先级就是决定线程需要多（少）分配一些处理器资源的线程属性。

  **注意：线程优先级属性不能决定线程是否优先执行**

  ## 12.3 java线程的状态

  ![1539158988013](https://github.com/Alan-Jun/study-note/blob/master/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.assets/1539158988013.png)

  







